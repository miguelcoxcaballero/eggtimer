<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>3D Photorealistic Pomodoro Timer</title>

<!-- Fonts for logo -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&family=Comfortaa:wght@300;400;700&display=swap" rel="stylesheet">

<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #e0e0e0;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none; /* Prevents default browser actions like zooming/scrolling */
    }

    #canvas-container {
        width: 100vw;
        height: 100vh;
        display: block;
    }

    #ui-overlay {
        position: absolute;
        bottom: 50px;
        width: 100%;
        text-align: center;
        color: rgba(0, 0, 0, 0.3);
        pointer-events: none;
        font-size: 14px;
        letter-spacing: 1px;
        font-weight: bold;
        transition: opacity 0.5s;
    }

    #tooltip {
        position: absolute;
        top: 10%;
        width: 100%;
        text-align: center;
        color: rgba(0, 0, 0, 0.5);
        font-size: 24px;
        font-weight: 300;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #333;
        font-size: 24px;
    }

    /* --- EGG TIMER LOGO (TOP, FADE OUT) --- */
    #egg-logo {
        position: absolute;
        top: 22px;
        width: 100%;
        text-align: center;
        font-family: 'Caveat', 'Comfortaa', cursive;
        font-size: 40px;
        color: rgba(0, 0, 0, 0.8);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.8s ease;
        text-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }

    /* --- INHOUSE LOGO WATERMARK --- */
    #watermark {
        position: absolute;
        bottom: 10px;
        left: 10px;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 0;
        background: transparent;
        border-radius: 0;
        color: #111111;
        font-size: 12px;
        font-weight: 500;
        opacity: 0.8;
        pointer-events: none;
        font-family: 'Comfortaa', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        text-transform: lowercase;
    }
    #watermark svg {
        height: 12px;
        width: 15px;
        stroke: #cc0000;
        stroke-width: 5;
    }
</style>
<!-- Import Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="loading" class="loading">Loading Timer...</div>
<div id="canvas-container"></div>
<div id="tooltip">00:00</div>
<div id="ui-overlay">SWIPE LEFT/RIGHT TO SET</div>

<!-- Egg Timer logo overlay -->
<div id="egg-logo">Egg Timer</div>

<!-- Inhouse Software Logo Watermark -->
<div id="watermark">
    <svg viewBox="0 0 100 60" fill="none" stroke="currentColor" stroke-width="4">
        <path d="M5 55 L50 10 L95 55" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    inhouse software
</div>

<script>
/**
 * AUDIO SYSTEM
 * - Tick/tock: mouse-click style, noise only.
 * - Bell: Additive synthesis for a pleasant, resonating meditation chime.
 */
class SoundEngine {
    constructor() {
        this.ctx = null;
        this.initialized = false;
        this.tickToggle = false;
        this.clickBuffer = null;
    }

    init() {
        if (this.initialized) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.initialized = true;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this._createClickBuffer();
    }

    _createClickBuffer() {
        if (!this.ctx || this.clickBuffer) return;
        const sampleRate = this.ctx.sampleRate;
        const length = Math.floor(sampleRate * 0.02);
        const buffer = this.ctx.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const env = 1 - i / length;
            data[i] = (Math.random() * 2 - 1) * env;
        }

        this.clickBuffer = buffer;
    }

    _mouseClick(time, variant) {
        const ctx = this.ctx;
        const src = ctx.createBufferSource();
        src.buffer = this.clickBuffer;

        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(variant ? 1800 : 2300, time);
        filter.Q.setValueAtTime(0.7, time);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.0, time);
        const peak = time + 0.002;
        const release = time + 0.03;
        gain.gain.linearRampToValueAtTime(variant ? 0.45 : 0.55, peak);
        gain.gain.exponentialRampToValueAtTime(0.001, release);

        src.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);

        src.start(time);
        src.stop(time + 0.04);
    }

    playTick() {
        if (!this.initialized || !this.clickBuffer) return;
        const t = this.ctx.currentTime;
        this._mouseClick(t, this.tickToggle ? 1 : 0);
        this.tickToggle = !this.tickToggle;
    }

    /**
     * Classic electronic phone ring
     */
    playPhoneRing() {
        if (!this.initialized) return;

        const t = this.ctx.currentTime;
        
        // Ring twice with a short pause
        this._ringBurst(t, 1.2);
        this._ringBurst(t + 1.6, 1.2);
    }

    _ringBurst(startTime, duration) {
        // Two oscillators for a slightly dissonant, classic telephone chord
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        osc1.type = 'square';
        osc2.type = 'square';
        osc1.frequency.setValueAtTime(550, startTime);
        osc2.frequency.setValueAtTime(650, startTime);

        // LFO for the rapid mechanical "brrrrr" clapper effect
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(25, startTime); // 25 Hz stutter

        const lfoGain = this.ctx.createGain();
        lfoGain.gain.setValueAtTime(0.5, startTime);
        
        const lfoAmount = this.ctx.createGain();
        lfoAmount.gain.setValueAtTime(0.5, startTime);
        lfo.connect(lfoAmount);
        lfoAmount.connect(lfoGain.gain);

        const masterGain = this.ctx.createGain();
        masterGain.gain.setValueAtTime(0, startTime);
        masterGain.gain.linearRampToValueAtTime(0.15, startTime + 0.05);
        masterGain.gain.setValueAtTime(0.15, startTime + duration - 0.05);
        masterGain.gain.linearRampToValueAtTime(0, startTime + duration);

        osc1.connect(lfoGain);
        osc2.connect(lfoGain);
        lfoGain.connect(masterGain);
        masterGain.connect(this.ctx.destination);

        osc1.start(startTime);
        osc2.start(startTime);
        lfo.start(startTime);
        osc1.stop(startTime + duration);
        osc2.stop(startTime + duration);
        lfo.stop(startTime + duration);
    }
}

const audio = new SoundEngine();

/**
 * SCENE SETUP
 */
const container = document.getElementById('canvas-container');
const tooltip = document.getElementById('tooltip');
const overlay = document.getElementById('ui-overlay');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xd0d0d0);
scene.fog = new THREE.Fog(0xd0d0d0, 20, 60);

// CONSTANTS FOR EGG GEOMETRY
const eggHeight = 6.2;
const splitHeight = 2.6;
const arrowHeight = splitHeight - 0.35; 

const timerGroupY = -3.0;

// --- CAMERA CONFIGURATION ---
const startFov = 60;
const startLookAt = new THREE.Vector3(0, 2.5, 0);
const startCamPos = new THREE.Vector3(0, 7.5, 13.5);

const pointerWorldY = timerGroupY + arrowHeight;
const dialWorldY    = timerGroupY + splitHeight;
const zoomCenterY = (pointerWorldY + dialWorldY) * 0.5;

const zoomFov = 40;
const zoomLookAt = new THREE.Vector3(0, zoomCenterY, 0);
const zoomCamPos = new THREE.Vector3(0, zoomCenterY + 2.0, 8.5);

const camera = new THREE.PerspectiveCamera(startFov, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.copy(startCamPos);
camera.lookAt(startLookAt);

// Animation State
const currentCamPos = startCamPos.clone();
const currentLookAt = startLookAt.clone();
let currentFov = startFov;

const targetCamPos = startCamPos.clone();
const targetLookAt = startLookAt.clone();
let targetFov = startFov;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.physicallyCorrectLights = true;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
container.appendChild(renderer.domElement);

/**
 * LIGHTING
 */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const keyLight = new THREE.RectAreaLight(0xffffff, 4, 10, 10);
keyLight.position.set(5, 10, 10);
keyLight.lookAt(0, 0, 0);
scene.add(keyLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.bias = -0.0005;
dirLight.shadow.radius = 4;
scene.add(dirLight);

const rimLight = new THREE.SpotLight(0xddeeff, 2);
rimLight.position.set(-10, 5, -5);
rimLight.lookAt(0, 2, 0);
scene.add(rimLight);

/**
 * TEXTURE GENERATION
 */
function createNoiseTexture() {
    const size = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const imgData = ctx.createImageData(size, size);
    const data = imgData.data;

    for (let i = 0; i < data.length; i += 4) {
        const val = Math.floor(Math.random() * 255);
        data[i] = val;
        data[i + 1] = val;
        data[i + 2] = val;
        data[i + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 16;
    tex.minFilter = THREE.LinearFilter;
    return tex;
}

const noiseTexBottom = createNoiseTexture();
const noiseTexTop = createNoiseTexture();

const density = 0.6;
noiseTexBottom.repeat.set(2, 2 * density);
noiseTexTop.repeat.set(12, 12 * density);

const matteWhite = new THREE.MeshStandardMaterial({
    color: 0xeeeeee,
    roughness: 0.65,
    metalness: 0.0,
    bumpMap: noiseTexBottom,
    bumpScale: 0.018,
    side: THREE.DoubleSide
});

const innerMatte = matteWhite;

const redMatte = new THREE.MeshStandardMaterial({
    color: 0xcc0000,
    roughness: 0.8,
    metalness: 0.1
});

/**
 * DIAL TEXTURE
 */
function createSolidDialTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 4096;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#111111';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = `bold 120px "Helvetica Neue", Helvetica, Arial, sans-serif`;

    const pixelsPerMin = canvas.width / 60;
    const bottomY = canvas.height;
    const tickHeightLong = 35;
    const tickHeightShort = 18;
    const textYOffset = 45;

    for (let i = 0; i < 60; i++) {
        const x = i * pixelsPerMin;
        let num = i;

        if (i % 5 === 0) {
            ctx.fillRect(x - 3, bottomY - tickHeightLong, 6, tickHeightLong);
            ctx.save();
            ctx.translate(x, bottomY - textYOffset);
            ctx.scale(1, 0.45);
            ctx.fillText(num.toString(), 0, 0);
            ctx.restore();

            if (i === 0) {
                ctx.fillRect(canvas.width - 3, bottomY - tickHeightLong, 6, tickHeightLong);
                ctx.save();
                ctx.translate(canvas.width, bottomY - textYOffset);
                ctx.scale(1, 0.45);
                ctx.fillText(num.toString(), 0, 0);
                ctx.restore();
            }
        } else {
            ctx.fillRect(x - 1, bottomY - tickHeightShort, 2, tickHeightShort);
        }
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 16;
    tex.wrapS = THREE.RepeatWrapping;
    tex.repeat.set(1, 1);
    tex.offset.x = 0.0;
    return tex;
}

const solidDialTex = createSolidDialTexture();

const texturedMatte = new THREE.MeshStandardMaterial({
    map: solidDialTex,
    roughness: 0.65,
    metalness: 0.0,
    bumpMap: noiseTexTop,
    bumpScale: 0.012
});

/**
 * GEOMETRY: The Egg
 */
const eggWidthCtrl = 3.6;

const curve = new THREE.CubicBezierCurve(
    new THREE.Vector2(2.2, 0.0),
    new THREE.Vector2(eggWidthCtrl, 2.0),
    new THREE.Vector2(2.5, eggHeight),
    new THREE.Vector2(0, eggHeight)
);

curve.v2 = new THREE.Vector2(1.8, eggHeight);
curve.v3 = new THREE.Vector2(0, eggHeight);

const allPoints = curve.getPoints(120);
allPoints.unshift(new THREE.Vector2(0, 0));

const bottomPoints = [];
const topPoints = [];
let splitAdded = false;

allPoints.forEach((p, i) => {
    if (p.y < splitHeight) {
        bottomPoints.push(p);
    } else {
        if (!splitAdded) {
            const prev = allPoints[i - 1];
            if (prev) {
                const alpha = (splitHeight - prev.y) / (p.y - prev.y);
                const rAtSplit = THREE.MathUtils.lerp(prev.x, p.x, alpha);
                const splitVec = new THREE.Vector2(rAtSplit, splitHeight);
                bottomPoints.push(splitVec);
                topPoints.push(splitVec);
            }
            splitAdded = true;
        }
        topPoints.push(p);
    }
});

const baseGeo = new THREE.LatheGeometry(bottomPoints, 64);
const topGeo = new THREE.LatheGeometry(topPoints, 64);

// MESHES
const timerGroup = new THREE.Group();
scene.add(timerGroup);
timerGroup.position.y = timerGroupY;

const baseMesh = new THREE.Mesh(baseGeo, matteWhite);
baseMesh.castShadow = true;
baseMesh.receiveShadow = true;
timerGroup.add(baseMesh);

const topGroup = new THREE.Group();
const seamGap = 0.075;
topGroup.position.y = seamGap;
timerGroup.add(topGroup);

const topMesh = new THREE.Mesh(topGeo, texturedMatte);
topMesh.castShadow = true;
topMesh.receiveShadow = true;
topGroup.add(topMesh);

// Pointer
const pointerShape = new THREE.Shape();
pointerShape.moveTo(-0.12, 0);
pointerShape.lineTo(0.12, 0);
pointerShape.lineTo(0, 0.20);
pointerShape.lineTo(-0.12, 0);

const pointerGeo = new THREE.ExtrudeGeometry(pointerShape, { depth: 0.04, bevelEnabled: false });
const pointerMesh = new THREE.Mesh(pointerGeo, redMatte);

const radiusAtSeam = bottomPoints[bottomPoints.length - 1].x;

pointerMesh.position.set(0, arrowHeight, radiusAtSeam + 0.05);
pointerMesh.rotation.x = -0.12;
baseMesh.add(pointerMesh);

// Caps
const capGeo = new THREE.CircleGeometry(radiusAtSeam - 0.01, 64);
const bottomCap = new THREE.Mesh(capGeo, innerMatte);
bottomCap.rotation.x = -Math.PI / 2;
bottomCap.position.y = splitHeight;
baseMesh.add(bottomCap);

const topCap = new THREE.Mesh(capGeo, innerMatte);
topCap.rotation.x = Math.PI / 2;
topCap.position.y = splitHeight;
topGroup.add(topCap);

// Floor
const planeGeo = new THREE.PlaneGeometry(100, 100);
const planeMat = new THREE.ShadowMaterial({ opacity: 0.05 });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI / 2;
plane.position.y = 0;
timerGroup.add(plane);

const bgPlane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ color: 0xe0e0e0 }));
bgPlane.rotation.x = -Math.PI / 2;
bgPlane.position.y = -0.1;
timerGroup.add(bgPlane);

/**
 * LOGIC & INTERACTION
 */
let isDragging = false;
let targetAngle = 0;
let visualAngle = 0;
let timerRunning = false;
let lastTickTime = 0;

// Variables for horizontal drag
let startX = 0;
let startAngle = 0;

const raycaster = new THREE.Raycaster();

function getClientX(e) {
    if (e.changedTouches && e.changedTouches.length > 0) {
        return e.changedTouches[0].clientX;
    } else if (e.touches && e.touches.length > 0) {
        return e.touches[0].clientX;
    }
    return e.clientX || 0;
}

function updateUI(rad) {
    let timeRad = -rad;
    let normRad = timeRad % (Math.PI * 2);
    if (normRad < 0) normRad += Math.PI * 2;

    let mins = Math.round((normRad / (Math.PI * 2)) * 60);
    if (mins < 0) mins = 0;
    if (mins > 60) mins = 60;
    if (mins === 60) mins = 0;
    tooltip.innerText = `${mins.toString().padStart(2, '0')}:00`;
    return mins;
}

function onDown(e) {
    audio.init();
    
    // Convert click/touch position to normalized device coordinates
    let clientX = getClientX(e);
    let clientY = e.clientY || (e.touches && e.touches.length > 0 ? e.touches[0].clientY : 0);
    
    let pickMouse = new THREE.Vector2();
    pickMouse.x = (clientX / window.innerWidth) * 2 - 1;
    pickMouse.y = -(clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(pickMouse, camera);
    const intersects = raycaster.intersectObject(topMesh);

    if (intersects.length > 0) {
        e.preventDefault();
        isDragging = true;
        timerRunning = false;

        // Reset zoom on interact
        targetCamPos.copy(startCamPos);
        targetLookAt.copy(startLookAt);
        targetFov = startFov;

        overlay.style.opacity = '0';
        tooltip.style.opacity = '1';
        document.body.style.cursor = 'grabbing';
        
        // Record starting positions for linear horizontal dragging
        startX = clientX;
        startAngle = targetAngle;
    }
}

function onMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const currentX = getClientX(e);
    const deltaX = currentX - startX;

    // Moving right (positive delta) -> Reversed direction to match expectations
    // Dragging 80% of the screen width equals a full 60 minute rotation
    const sensitivity = (Math.PI * 2) / (window.innerWidth * 0.8);
    
    targetAngle = startAngle + (deltaX * sensitivity);

    // Clamp between 0 and 60 minutes
    if (targetAngle > 0) targetAngle = 0;
    if (targetAngle < -Math.PI * 2) targetAngle = -Math.PI * 2;
}

function onUp(e) {
    if (isDragging) {
        isDragging = false;
        const mins = updateUI(targetAngle);
        if (mins > 0) {
            timerRunning = true;
            // ZOOM IN to pointer + numbers
            targetCamPos.copy(zoomCamPos);
            targetLookAt.copy(zoomLookAt);
            targetFov = zoomFov;
        } else {
            targetAngle = 0;
            overlay.style.opacity = '1';
            // ZOOM OUT
            targetCamPos.copy(startCamPos);
            targetLookAt.copy(startLookAt);
            targetFov = startFov;
        }
        tooltip.style.opacity = '0';
        document.body.style.cursor = 'default';
    }
}

window.addEventListener('mousedown', onDown, { passive: false });
window.addEventListener('mousemove', onMove, { passive: false });
window.addEventListener('mouseup', onUp);
window.addEventListener('touchstart', onDown, { passive: false });
window.addEventListener('touchmove', onMove, { passive: false });
window.addEventListener('touchend', onUp);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('loading').style.display = 'none';

const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    if (timerRunning) {
        if (Math.abs(targetAngle) > 0.001) {
            const speed = (Math.PI * 2) / 3600;
            if (targetAngle < 0) targetAngle += speed * dt;
            else targetAngle -= speed * dt;

            const now = Date.now();

            if (now - lastTickTime > 250) {
                audio.playTick();
                lastTickTime = now;
            }

            if (Math.abs(targetAngle) < 0.002) {
                targetAngle = 0;
                timerRunning = false;
                audio.playPhoneRing(); // Using the new phone ring!
                overlay.style.opacity = '1';

                // ZOOM OUT
                targetCamPos.copy(startCamPos);
                targetLookAt.copy(startLookAt);
                targetFov = startFov;
            }
        }
    }

    const smoothing = 0.15;
    visualAngle += (targetAngle - visualAngle) * smoothing;
    topGroup.rotation.y = visualAngle;

    // Smooth Camera Animation (Position + LookAt + FOV)
    const camSpeed = 0.02;
    currentCamPos.lerp(targetCamPos, camSpeed);
    currentLookAt.lerp(targetLookAt, camSpeed);
    currentFov += (targetFov - currentFov) * camSpeed;

    camera.position.copy(currentCamPos);
    camera.lookAt(currentLookAt);
    camera.fov = currentFov;
    camera.updateProjectionMatrix();

    if (isDragging || Math.abs(targetAngle - visualAngle) > 0.001) {
        updateUI(visualAngle);
    }

    renderer.render(scene, camera);
}
animate();

// --- EGG LOGO FADE-IN / FADE-OUT ---
const eggLogo = document.getElementById('egg-logo');
setTimeout(() => {
    eggLogo.style.opacity = '1';
    setTimeout(() => {
        eggLogo.style.opacity = '0';
    }, 3000);
}, 150);
</script>
</body>
</html>
